@workInProgress
@ngdoc overview
@name Developer Guide: E2E Testing
@description

アプリケーションが肥大化し複雑さを増すと､手動でのテストに頼って新しい機能が正しく動いていることを確認するのは非現実的になります｡

この問題に対処するために､我々Angular開発チームは Angularシナリオランナーを開発しました｡Angularシナリオランナーは､ユーザーの操作をシミュレートすることで､Angularアプリケーションが常に正しく動いていることを検証する手助けをします｡

# 概要
テストシナリオはJavaScriptで記述します｡シナリオには特定の状況のユーザー操作に対して､アプリケーションがどのような振る舞いをするのかを詳しく書きます｡
シナリオは一つまたは複数の`it`ブロック(これをアプリケーションの要求仕様とみなすことが出来るでしょう)から成り､`it`ブロックは**コマンド**や**期待値の確認**から構成されます｡
コマンドはテストランナーにアプリケーションの操作（たとえばページ移動とかボタンクリックとか）をするように指示するもので､期待値の確認はテストランナーに状態の確認（たとえば入力フィールドの値とか現在のURLとか）をするよう指示します｡
期待値の確認が失敗すると､テストランナーはその`it`ブロックを「失敗」として記録し､次のテストケースを実行します｡シナリオに**beforeEach**ブロックや**afterEach**ブロックがある場合､各`it`ブロックが実行される前後にそれらが実行されます｡これらの前後処理は`it`ブロックが成功しているか失敗しているかに関わらず実行されます｡

<img src="img/guide/scenario_runner.png">

上記の要素に加えて､シナリオには`it`内での処理の重複を避けるための関数を含めることもできます｡

シナリオの例は次のようになります:
<pre>
describe('Buzz Client', function() {
it('should filter results', function() {
  input('user').enter('jacksparrow');
  element(':button').click();
  expect(repeater('ul li').count()).toEqual(10);
  input('filterText').enter('Bees');
  expect(repeater('ul li').count()).toEqual(1);
});
});
</pre>
This scenario describes the requirements of a Buzz Client, specifically, that it should be able to
filter the stream of the user. It starts by entering a value in the 'user' input field, clicking
the only button on the page, and then it verifies that there are 10 items listed. It then enters
'Bees' in the 'filterText' input field and verifies that the list is reduced to a single item.
このシナリオにはBuzzクライアントの要求仕様を記述してあります｡それによるとBuzzクライアントはユーザーに表示する内容をフィルタリング出来なければいけません｡
まず`user`入力フィールドに値を入力し､ページにある唯一のボタンをクリックすると､10個のアイテムが表示されることを検証します｡
次に､`filterText`入力フィールドに`Bees`と入力すると､リストが1つのアイテムに減ることを検証します｡

次のAPIセクションではテストランナーで利用可能なコマンドと期待値の確認方法の一覧を示します｡

# API
Source: {@link https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js}

## pause()
Pauses the execution of the tests until you call `resume()` in the console (or click the resume
link in the Runner UI).


## sleep(seconds)
Pauses the execution of the tests for the specified number of `seconds`.

## browser().navigateTo(url)
Loads the `url` into the test frame.

## browser().navigateTo(url, fn)
Loads the URL returned by `fn` into the testing frame. The given `url` is only used for the test
output. Use this when the destination URL is dynamic (that is, the destination is unknown when you
write the test).

## browser().reload()
Refreshes the currently loaded page in the test frame.

## browser().window().href()
Returns the window.location.href of the currently loaded page in the test frame.

## browser().window().path()
Returns the window.location.pathname of the currently loaded page in the test frame.

## browser().window().search()
Returns the window.location.search of the currently loaded page in the test frame.

## browser().window().hash()
Returns the window.location.hash (without `#`) of the currently loaded page in the test frame.

## browser().location().url()
Returns the {@link api/ng.$location $location.url()} of the currently loaded page in
the test frame.

## browser().location().path()
Returns the {@link api/ng.$location $location.path()} of the currently loaded page in
the test frame.

## browser().location().search()
Returns the {@link api/ng.$location $location.search()} of the currently loaded page
in the test frame.

## browser().location().hash()
Returns the {@link api/ng.$location $location.hash()} of the currently loaded page in
the test frame.

## expect(future).{matcher}
Asserts the value of the given `future` satisfies the `matcher`. All API statements return a
`future` object, which get a `value` assigned after they are executed. Matchers are defined using
`angular.scenario.matcher`, and they use the value of futures to run the expectation. For example:
`expect(browser().location().href()).toEqual('http://www.google.com')`

## expect(future).not().{matcher}
Asserts the value of the given `future` satisfies the negation of the `matcher`.

## using(selector, label)
Scopes the next DSL element selection.

## binding(name)
Returns the value of the first binding matching the given `name`.

## input(name).enter(value)
Enters the given `value` in the text field with the given `name`.

## input(name).check()
Checks/unchecks the checkbox with the given `name`.

## input(name).select(value)
Selects the given `value` in the radio button with the given `name`.

## input(name).val()
Returns the current value of an input field with the given `name`.

## repeater(selector, label).count()
Returns the number of rows in the repeater matching the given jQuery `selector`. The `label` is
used for test output.

## repeater(selector, label).row(index)
Returns an array with the bindings in the row at the given `index` in the repeater matching the
given jQuery `selector`. The `label` is used for test output.

## repeater(selector, label).column(binding)
Returns an array with the values in the column with the given `binding` in the repeater matching
the given jQuery `selector`. The `label` is used for test output.

## select(name).option(value)
Picks the option with the given `value` on the select with the given `name`.

## select(name).option(value1, value2...)
Picks the options with the given `values` on the multi select with the given `name`.

## element(selector, label).count()
Returns the number of elements that match the given jQuery `selector`. The `label` is used for test
output.

## element(selector, label).click()
Clicks on the element matching the given jQuery `selector`. The `label` is used for test output.

## element(selector, label).query(fn)
Executes the function `fn(selectedElements, done)`, where selectedElements are the elements that
match the given jQuery `selector` and `done` is a function that is called at the end of the `fn`
function.  The `label` is used for test output.

## element(selector, label).{method}()
Returns the result of calling `method` on the element matching the given jQuery `selector`, where
`method` can be any of the following jQuery methods: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`. The `label` is used for test output.

## element(selector, label).{method}(value)
Executes the `method` passing in `value` on the element matching the given jQuery `selector`, where
`method` can be any of the following jQuery methods: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`.  The `label` is used for test output.

## element(selector, label).{method}(key)
Returns the result of calling `method` passing in `key` on the element matching the given jQuery
`selector`, where `method` can be any of the following jQuery methods: `attr`, `prop`, `css`. The
`label` is used for test output.

## element(selector, label).{method}(key, value)
Executes the `method` passing in `key` and `value` on the element matching the given jQuery
`selector`, where `method` can be any of the following jQuery methods: `attr`,  `prop`, `css`.  The
`label` is used for test output.

JavaScript is a dynamically typed language which comes with great power of expression, but it also
come with almost no-help from the compiler. For this reason we feel very strongly that any code
written in JavaScript needs to come with a strong set of tests. We have built many features into
angular which makes testing your angular applications easy. So there is no excuse for not testing.
