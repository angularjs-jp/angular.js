@workInProgress
@ngdoc overview
@name Developer Guide: E2E Testing
@description

アプリケーションが肥大化し複雑さを増すと､手動でのテストに頼って新しい機能が正しく動いていることを確認するのは非現実的になります｡

この問題に対処するために､我々Angular開発チームは Angularシナリオランナーを開発しました｡Angularシナリオランナーは､ユーザーの操作をシミュレートすることで､Angularアプリケーションが常に正しく動いていることを検証する手助けをします｡

# 概要
テストシナリオはJavaScriptで記述します｡シナリオには特定の状況のユーザー操作に対して､アプリケーションがどのような振る舞いをするのかを詳しく書きます｡
シナリオは一つまたは複数の`it`ブロック(これをアプリケーションの要求仕様とみなすことが出来るでしょう)から成り､`it`ブロックは**コマンド**や**アサート**から構成されます｡
コマンドはテストランナーにアプリケーションの操作（たとえばページ移動とかボタンクリックとか）をするように指示するもので､アサートはテストランナーに状態の確認（たとえば入力フィールドの値とか現在のURLとか）をするよう指示します｡
アサートが失敗すると､テストランナーはその`it`ブロックを「失敗」として記録し､次のテストケースを実行します｡シナリオに**beforeEach**ブロックや**afterEach**ブロックがある場合､各`it`ブロックが実行される前後にそれらが実行されます｡これらの前後処理は`it`ブロックが成功しているか失敗しているかに関わらず実行されます｡

<img src="img/guide/scenario_runner.png">

上記の要素に加えて､シナリオには`it`内での処理の重複を避けるための関数を含めることもできます｡

シナリオの例は次のようになります:
<pre>
describe('Buzz Client', function() {
it('should filter results', function() {
  input('user').enter('jacksparrow');
  element(':button').click();
  expect(repeater('ul li').count()).toEqual(10);
  input('filterText').enter('Bees');
  expect(repeater('ul li').count()).toEqual(1);
});
});
</pre>
このシナリオにはBuzzクライアントの要求仕様を記述してあります｡
その内容は､Buzzクライアントはユーザーに表示する内容をフィルタリングできることです｡
まず'user'入力フィールドに値を入力し､ページにある唯一のボタンをクリックすると､10個のアイテムが表示されることを検証します｡
次に､'filterText'入力フィールドに'Bees'と入力すると､リストが1つのアイテムに減ることを検証します｡

次のAPIセクションではテストランナーで利用可能なコマンドとアサート方法の一覧を示します｡

# API
Source: {@link https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js}

## pause()
テストの実行を一時停止します｡ コンソールで `resume()` が呼ばれるか､ Runner UI の resume リンクがクリックされると実行が再開されます｡

## sleep(seconds)
指定された `秒`数だけテストの実行を停止します｡

## browser().navigateTo(url)
テストフレーム内に `url` を読み込みます｡

## browser().navigateTo(url, fn)
`fn` で指定された関数が返すURLをテストフレームに読み込みます｡
第一引数の `url` はテスト結果表示のためだけに使われます｡URLが動的に決定されるなど､テストを書いている時にURLがわからない時にこの引数を使ってください｡

## browser().reload()
現在テストフレーム内に読み込まれているページを再読み込みします｡

## browser().window().href()
現在テストフレーム内に読み込まれているページの window.location.href を返します｡

## browser().window().path()
現在テストフレーム内に読み込まれているページの window.location.pathname を返します｡

## browser().window().search()
現在テストフレーム内に読み込まれているページの window.location.search を返します｡

## browser().window().hash()
現在テストフレーム内に読み込まれているページの window.location.hash を `#`無しで返します｡

## browser().location().url()
現在テストフレーム内に読み込まれているページの {@link api/ng.$location $location.url()} を返します｡

## browser().location().path()
現在テストフレーム内に読み込まれているページの {@link api/ng.$location $location.path()} を返します｡

## browser().location().search()
現在テストフレーム内に読み込まれているページの {@link api/ng.$location $location.search()} を返します｡

## browser().location().hash()
現在テストフレーム内に読み込まれているページの {@link api/ng.$location $location.hash()} を返します｡

## expect(future).{matcher}
`future`の値が`matcher`と一致するかを検証します｡API命令文はすべて`future`オブジェクトを返します｡
このオブジェクトは実行された後､その結果を`value`として保持します｡
Matcherは`angular.scenario.matcher`にて定義されています｡
Matcherはfutureの値を使って期待値の懸賞を行います｡
例:
`expect(browser().location().href()).toEqual('http://www.google.com')`

## expect(future).not().{matcher}
`future`の値が`matcher`と一致しないことを検証します｡

## using(selector, label)
次のDSL要素のスコープを使います｡
Scopes the next DSL element selection.

## binding(name)
スコープ内にバインドされた変数のうち､`name`に一致する最初の値を返します｡
Returns the value of the first binding matching the given `name`.

## input(name).enter(value)
ng-modelが`name`と一致するテキストフィールドの値に`value`を入力します｡

## input(name).check()
ng-modelが`name`と一致するチェックボックスをチェック済みにするかチェックを外します｡

## input(name).select(value)
ng-modelが`name`と一致するラジオボタンのうち､`value`を選択状態にします｡

## input(name).val()
ng-modelが`name`と一致する入力フィールドの現在の値を返します｡

## repeater(selector, label).count()
jQuery形式の`selector`に一致する繰り返しの行の数を返します｡
`label`はテスト結果出力で表示されます｡

## repeater(selector, label).row(index)
jQuery形式の`selector`に一致する繰り返しの行のうち､`index`番目の行の内容を返します｡
`label`はテスト結果出力で表示されます｡

## repeater(selector, label).column(binding)
jQuery形式の`selector`に一致する繰り返しの行のうち､`binding`で指定された列の内容を返します
`label`はテスト結果出力で表示されます｡

## select(name).option(value)
ng-modelが`name`と一致するドロップダウンのオプションのうち､`value`に一致するものを選択します｡

## select(name).option(value1, value2...)
ng-modelが`name`と一致するドロップダウンの選択肢のうち､`values`に一致する複数のオプションを選択します｡

## element(selector, label).count()
jQuery形式の`selector`に一致する要素の数を返します
`label`はテスト結果出力で表示されます｡

## element(selector, label).click()
jQuery形式の`selector`に一致する要素をクリックします
`label`はテスト結果出力で表示されます｡

## element(selector, label).query(fn)
引数で指定された関数 `fn(selectedElements, done)` を実行します｡
selectedElements は jQuery形式の`selector`に一致した要素で､`done`は`fn`関数の最後で呼ばれる関数です｡
`label`はテスト結果出力で表示されます｡

## element(selector, label).{method}()
jQuery形式の`selector`に一致する要素に対して､`method`を呼び出した結果を返します｡
`method`には次のjQueryメソッドが使えます: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`｡
`label`はテスト結果出力で表示されます｡

## element(selector, label).{method}(value)
jQuery形式の`selector`に一致する要素に対して､`method`を引数`value`で実行します｡
`method`には次のjQueryメソッドが使えます: `val`, `text`, `html`, `height`,
`innerHeight`, `outerHeight`, `width`, `innerWidth`, `outerWidth`, `position`, `scrollLeft`,
`scrollTop`, `offset`｡
`label`はテスト結果出力で表示されます｡

## element(selector, label).{method}(key)
jQuery形式の`selector`に一致する要素に対して､`method`を引数`key`で呼び出した結果を返します｡
`method`には次のjQueryメソッドが使えます: `attr`, `prop`, `css`｡
`label`はテスト結果出力で表示されます｡

## element(selector, label).{method}(key, value)
jQuery形式の`selector`に一致する要素に対して､`method`を引数`key`と`value`で実行します｡
`method`には次のjQueryメソッドが使えます: `attr`, `prop`, `css`｡
`label`はテスト結果出力で表示されます｡

Javascriptは動的片付けの言語であり､式の偉大なパワーを備えています｡しかしそれは同時にコンパイラの助けがないという事でもあります｡そのため､すべてのJavascriptコードはしっかりしたテストを備えている必要があると､我々は考えています｡
angularにはテストを容易にする多くの機能が備わっています｡
テストを書かない言い訳はできません｡
